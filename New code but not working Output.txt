--- C:\users\graham\Documents\GitHub\ai_automation_suggester\.github\workflows\hacs.yaml ---
name: HACS Action

on:
  push:
  pull_request:
  schedule:
    - cron: "0 0 * * *"

jobs:
  hacs:
    name: HACS Action
    runs-on: "ubuntu-latest"
    steps:
      - uses: "actions/checkout@v2"
      - name: HACS Action
        uses: "hacs/action@main"
        with:
          category: "integration"


--- C:\users\graham\Documents\GitHub\ai_automation_suggester\.github\workflows\hassfest.yaml ---
name: Validate with hassfest

on:
  push:
  pull_request:
  schedule:
    - cron: "0 0 * * *"

jobs:
  validate:
    runs-on: "ubuntu-latest"
    steps:
      - uses: "actions/checkout@v2"
      - uses: home-assistant/actions/hassfest@master


--- C:\users\graham\Documents\GitHub\ai_automation_suggester\.github\workflows\validate.yaml ---
name: Validate

on:
  push:
  pull_request:
  schedule:
    - cron: "0 0 * * *"
  workflow_dispatch:

jobs:
  validate-hacs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.9"
      - name: HACS validation
        uses: hacs/action@main
        with:
          category: "integration"



--- C:\users\graham\Documents\GitHub\ai_automation_suggester\custom_components\ai_automation_suggester\translations\en.json ---
{
  "config": {
    "step": {
      "user": {
        "title": "Configure AI Automation Suggester",
        "data": {
          "scan_frequency": "Scan Frequency (hours)",
          "use_local_ai": "Use Local AI",
          "openai_api_key": "OpenAI API Key"
        }
      }
    },
    "error": {
      "required": "This field is required."
    }
  }
}



--- C:\users\graham\Documents\GitHub\ai_automation_suggester\custom_components\ai_automation_suggester\config_flow.py ---
"""Config flow for AI Automation Suggester integration."""
import logging

import voluptuous as vol

from homeassistant import config_entries
from homeassistant.core import callback

from .const import DOMAIN

_LOGGER = logging.getLogger(__name__)


class AIAutomationConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):
    """Handle a config flow for AI Automation Suggester."""

    VERSION = 1

    async def async_step_user(self, user_input=None):
        """Handle the initial step."""
        errors = {}
        if user_input is not None:
            try:
                # Validate API key if using cloud AI
                if not user_input.get("use_local_ai") and not user_input.get("openai_api_key"):
                    errors["openai_api_key"] = "required"
                else:
                    # Validate the OpenAI API key
                    if not user_input.get("use_local_ai"):
                        await self.hass.async_add_executor_job(
                            self.validate_openai_api_key,
                            user_input.get("openai_api_key")
                        )
                    return self.async_create_entry(title="AI Automation Suggester", data=user_input)
            except ValueError as e:
                _LOGGER.error(f"Error during config flow: {e}")
                errors["base"] = "invalid_api_key"
            except Exception as e:
                _LOGGER.error(f"Unexpected error during config flow: {e}")
                errors["base"] = "cannot_connect"

        data_schema = vol.Schema({
            vol.Required("scan_frequency", default=24): vol.All(vol.Coerce(int), vol.Range(min=1)),
            vol.Required("use_local_ai", default=False): bool,
            vol.Optional("openai_api_key"): str,
        })
        return self.async_show_form(step_id="user", data_schema=data_schema, errors=errors)

    def validate_openai_api_key(self, api_key):
        """Validate the OpenAI API key."""
        import openai
        openai.api_key = api_key
        try:
            openai.Engine.list()
        except openai.error.AuthenticationError:
            raise ValueError("Invalid OpenAI API key")
        except Exception as e:
            raise e

    @staticmethod
    @callback
    def async_get_options_flow(config_entry):
        """Get the options flow."""
        return AIAutomationOptionsFlowHandler(config_entry)


class AIAutomationOptionsFlowHandler(config_entries.OptionsFlow):
    """Handle options flow."""

    def __init__(self, config_entry):
        """Initialize options flow."""
        self.config_entry = config_entry

    async def async_step_init(self, user_input=None):
        """Manage the AI Automation Suggester options."""
        errors = {}
        if user_input is not None:
            try:
                # Validate API key if using cloud AI
                if not user_input.get("use_local_ai") and not user_input.get("openai_api_key"):
                    errors["openai_api_key"] = "required"
                else:
                    # Validate the OpenAI API key
                    if not user_input.get("use_local_ai"):
                        await self.hass.async_add_executor_job(
                            self.validate_openai_api_key,
                            user_input.get("openai_api_key")
                        )
                    return self.async_create_entry(title="", data=user_input)
            except ValueError as e:
                _LOGGER.error(f"Error during options flow: {e}")
                errors["base"] = "invalid_api_key"
            except Exception as e:
                _LOGGER.error(f"Unexpected error during options flow: {e}")
                errors["base"] = "cannot_connect"

        data_schema = vol.Schema({
            vol.Required("scan_frequency", default=self.config_entry.options.get("scan_frequency", 24)):
                vol.All(vol.Coerce(int), vol.Range(min=1)),
            vol.Required("use_local_ai", default=self.config_entry.options.get("use_local_ai", False)): bool,
            vol.Optional("openai_api_key", default=self.config_entry.options.get("openai_api_key", "")): str,
        })

        return self.async_show_form(step_id="init", data_schema=data_schema, errors=errors)

    def validate_openai_api_key(self, api_key):
        """Validate the OpenAI API key."""
        import openai
        openai.api_key = api_key
        try:
            openai.Engine.list()
        except openai.error.AuthenticationError:
            raise ValueError("Invalid OpenAI API key")
        except Exception as e:
            raise e



--- C:\users\graham\Documents\GitHub\ai_automation_suggester\custom_components\ai_automation_suggester\const.py ---
"""Constants for the AI Automation Suggester integration."""

DOMAIN = "ai_automation_suggester"
PLATFORMS = ["sensor"]



--- C:\users\graham\Documents\GitHub\ai_automation_suggester\custom_components\ai_automation_suggester\coordinator.py ---
"""Coordinator for AI Automation Suggester."""
import logging
from datetime import timedelta

from homeassistant.components.persistent_notification import async_create
from homeassistant.core import HomeAssistant
from homeassistant.helpers.update_coordinator import DataUpdateCoordinator

from .const import DOMAIN

_LOGGER = logging.getLogger(__name__)


class AIAutomationCoordinator(DataUpdateCoordinator):
    """Class to manage fetching data from AI model."""

    def __init__(self, hass: HomeAssistant, entry):
        """Initialize."""
        self.hass = hass
        self.entry = entry
        update_interval = timedelta(hours=entry.data.get("scan_frequency", 24))
        super().__init__(hass, _LOGGER, name=DOMAIN, update_interval=update_interval)
        self.previous_entities = {}

    async def _async_update_data(self):
        """Fetch data from AI model."""
        # Fetch the list of current entities
        current_entities = {
            entity_id: self.hass.states.get(entity_id).as_dict()
            for entity_id in self.hass.states.async_entity_ids()
        }

        # Detect newly added entities
        new_entities = {
            k: v for k, v in current_entities.items() if k not in self.previous_entities
        }

        # Limit the number of new entities to process
        MAX_NEW_ENTITIES = 10
        total_new_entities = len(new_entities)
        if total_new_entities > MAX_NEW_ENTITIES:
            # Limit the new_entities to MAX_NEW_ENTITIES
            new_entities = dict(list(new_entities.items())[:MAX_NEW_ENTITIES])

        # Prepare data for AI analysis
        ai_input_data = {
            "new_entities": new_entities,
        }

        # Process data with AI model
        suggestions = await self.hass.async_add_executor_job(
            self.get_ai_suggestions, ai_input_data
        )

        # Update previous entities
        self.previous_entities = current_entities

        # Create a persistent notification with suggestions
        if suggestions:
            async_create(
                hass=self.hass,
                title="AI Automation Suggestions",
                message=suggestions,
                notification_id="ai_automation_suggestions"
            )

        return suggestions

    def get_ai_suggestions(self, ai_input_data):
        """Process data with AI model (synchronously)."""
        use_local_ai = self.entry.data.get("use_local_ai", False)
        if use_local_ai:
            # Implement local AI processing
            return self.local_ai_analysis(ai_input_data)
        else:
            # Implement cloud AI processing
            return self.cloud_ai_analysis(ai_input_data)

    def local_ai_analysis(self, ai_input_data):
        """Analyze data using a local AI model."""
        # Placeholder for local AI logic
        return "Local AI analysis is not yet implemented."

    def cloud_ai_analysis(self, ai_input_data):
        """Analyze data using the OpenAI ChatCompletion API."""
        import openai

        api_key = self.entry.data.get("openai_api_key")
        if not api_key:
            _LOGGER.error("OpenAI API key is missing.")
            return "OpenAI API key is missing."

        openai.api_key = api_key

        prompt = self.generate_prompt(ai_input_data)
        try:
            response = openai.ChatCompletion.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": "You are an AI assistant that suggests Home Assistant automations based on new entities.",
                    },
                    {"role": "user", "content": prompt},
                ],
                max_tokens=500,
                n=1,
                temperature=0.7,
            )

            suggestions = response.choices[0].message.content.strip()
            return suggestions
        except Exception as e:
            _LOGGER.error(f"Error communicating with OpenAI: {e}")
            return f"Error communicating with OpenAI: {e}"

    def generate_prompt(self, ai_input_data):
        """Generate prompt for AI model."""
        # Simplify the data to make the prompt manageable
        new_entities_list = [
            f"{entity_id}: {entity['state']}"
            for entity_id, entity in ai_input_data['new_entities'].items()
        ]

        # Limit the number of entities included
        MAX_ENTITIES = 10
        total_new_entities = len(new_entities_list)
        if total_new_entities > MAX_ENTITIES:
            new_entities_list = new_entities_list[:MAX_ENTITIES]
            entities_info = f"{MAX_ENTITIES} of {total_new_entities} new entities"
        else:
            entities_info = f"{total_new_entities} new entities"

        prompt = (
            f"Analyze the following {entities_info} added to my Home Assistant setup and suggest potential automations:\n"
        )
        prompt += "\n".join(new_entities_list)
        prompt += "\n\nProvide the suggestions in a clear and concise manner."
        return prompt



--- C:\users\graham\Documents\GitHub\ai_automation_suggester\custom_components\ai_automation_suggester\manifest.json ---
{
  "domain": "ai_automation_suggester",
  "name": "AI Automation Suggester",
  "codeowners": ["@ITSpecialist111"],
  "config_flow": true,
  "dependencies": [],
  "documentation": "https://github.com/ITSpecialist111/ai_automation_suggester",
  "iot_class": "cloud_polling",
  "issue_tracker": "https://github.com/ITSpecialist111/ai_automation_suggester/issues",
  "requirements": ["openai>=1.0.0,<2.0.0"],
  "version": "1.0.0"
}




--- C:\users\graham\Documents\GitHub\ai_automation_suggester\custom_components\ai_automation_suggester\sensor.py ---
"""Sensor platform for AI Automation Suggester."""
from homeassistant.components.sensor import SensorEntity
from homeassistant.helpers.update_coordinator import CoordinatorEntity

from .const import DOMAIN


async def async_setup_entry(hass, entry, async_add_entities):
    """Set up the sensor platform."""
    coordinator = hass.data[DOMAIN][entry.entry_id]
    async_add_entities([AISuggestionsSensor(coordinator)], True)


class AISuggestionsSensor(CoordinatorEntity, SensorEntity):
    """Sensor to display AI suggestions."""

    def __init__(self, coordinator):
        """Initialize the sensor."""
        super().__init__(coordinator)
        self._attr_name = "AI Automation Suggestions"
        self._attr_unique_id = "ai_automation_suggestions_sensor"
        self._attr_icon = "mdi:robot"

    @property
    def state(self):
        """Return the state of the sensor."""
        if self.coordinator.data:
            return "Suggestions Available"
        return "No Suggestions"

    @property
    def extra_state_attributes(self):
        """Return the state attributes."""
        return {"suggestions": self.coordinator.data}



--- C:\users\graham\Documents\GitHub\ai_automation_suggester\custom_components\ai_automation_suggester\services.yaml ---
generate_suggestions:
  name: Generate Suggestions
  description: "Manually trigger AI automation suggestions."
  fields: {}



--- C:\users\graham\Documents\GitHub\ai_automation_suggester\custom_components\ai_automation_suggester\strings.json ---
{
  "title": "AI Automation Suggester",
  "config": {
    "step": {
      "user": {
        "title": "Configure AI Automation Suggester",
        "data": {
          "scan_frequency": "Scan Frequency (hours)",
          "openai_api_key": "OpenAI API Key"
        }
      }
    },
    "error": {
      "required": "This field is required."
    }
  },
  "services": {
    "generate_suggestions": {
      "name": "Generate Suggestions",
      "description": "Manually trigger AI automation suggestions."
    }
  }
}



--- C:\users\graham\Documents\GitHub\ai_automation_suggester\custom_components\ai_automation_suggester\__init__.py ---
"""The AI Automation Suggester integration."""

import logging
import voluptuous as vol
import homeassistant.helpers.config_validation as cv
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant

from .const import DOMAIN, PLATFORMS
from .coordinator import AIAutomationCoordinator

_LOGGER = logging.getLogger(__name__)

CONFIG_SCHEMA = cv.config_entry_only_config_schema

async def async_setup(hass: HomeAssistant, config: dict):
    """Set up the AI Automation Suggester component."""
    hass.data.setdefault(DOMAIN, {})
    return True


async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry):
    """Set up AI Automation Suggester from a config entry."""
    coordinator = AIAutomationCoordinator(hass, entry)
    hass.data[DOMAIN][entry.entry_id] = coordinator

    await coordinator.async_config_entry_first_refresh()

    await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)

    async def handle_generate_suggestions(call):
        """Handle the service call to generate suggestions."""
        await coordinator.async_request_refresh()

    hass.services.async_register(DOMAIN, "generate_suggestions", handle_generate_suggestions)

    return True


async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry):
    """Unload a config entry."""
    unload_ok = await hass.config_entries.async_unload_platforms(entry, PLATFORMS)
    hass.data[DOMAIN].pop(entry.entry_id)
    return unload_ok



--- C:\users\graham\Documents\GitHub\ai_automation_suggester\hacs.json ---
{
    "name": "AI Automation Suggester",
    "content_in_root": false,
    "homeassistant": "2024.10.2"
  }


